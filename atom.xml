<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ambeta.github.io</id>
    <title>三土 | AmBeta</title>
    <updated>2021-03-19T10:35:14.030Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ambeta.github.io"/>
    <link rel="self" href="https://ambeta.github.io/atom.xml"/>
    <subtitle>一个伪程序猿的自我拉扯</subtitle>
    <logo>https://ambeta.github.io/images/avatar.png</logo>
    <icon>https://ambeta.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 三土 | AmBeta</rights>
    <entry>
        <title type="html"><![CDATA[《武汉日记》方方]]></title>
        <id>https://ambeta.github.io/post/lesslesswu-han-ri-ji-greatergreater-fang-fang/</id>
        <link href="https://ambeta.github.io/post/lesslesswu-han-ri-ji-greatergreater-fang-fang/">
        </link>
        <updated>2020-08-03T14:36:21.000Z</updated>
        <content type="html"><![CDATA[<p>最近读了疫情期间在网络上吵得很凶的“方方日记”，通篇看下来，觉得文字朴实无华，也清晰真实地记录了武汉疫情封城期间的点滴。日记里面有很多对政府工作的批评，但也充分表达了对官方的信任，都是正常百姓心中所想。</p>
<p>作为一个在当代敢于写文字批评政府的作家，委实感到敬佩。而她六十多岁高龄还受到网络暴力，实在表示心疼，希望她不要过于在意网络上的评论。</p>
<blockquote>
<p>究竟有什么事让他们对一个素未谋面的人、一个他们毫无了解的人有这样意欲大卸八块的刻骨之恨呢？难道他们自小接受的教育不是真与善而是仇与恨？</p>
</blockquote>
<blockquote>
<p>这让人实在无法理解是什么样的动力让他们有这么多仇恨。好像，他们一生都在咬牙切齿。仇恨很多人，仇恨很多事。</p>
</blockquote>
<blockquote>
<p>像隔离病毒一样，与会咬人的群狗隔离，这就是常识。</p>
</blockquote>
<blockquote>
<p>记得我曾经跟某部门的一位负责人说：你们怎么可以让这样一些人去指导学生呢？他们中有的人就是流氓呀。可惜，对方没有听。现在，当年的那些被号召上网展示正能量的人，被指导成今天的他们。</p>
</blockquote>
<p>方方给网络上一个16岁孩子来信的回复：</p>
<blockquote>
<p>我要说，孩子，你写得不错，充满着你那个年龄人的疑惑。你的想法很适合你，你的疑惑是教育你的人给的。但是，我要跟你说的是：我无法解答你的疑惑。<br>
看到你的文字，倒让我想起很多年前我读过的一首诗。这首诗是白桦写的，不知道你有没有听说过他：一个才华横溢的诗人和剧作家哦。<br>
我读这首诗的年龄大约是12岁，这是在1967年的“文革”中。那时，整个武汉的夏天，都在武斗。就在这年，我这个小学五年级学生，得到了白桦的一本诗集，诗集名为：《迎着铁矛散发的传单》。其中第一首诗是《我也有过你们这样的青春》。诗的第一句：“我也有过你们这样的青春，那时的我们就像今天的你们。”我读这首诗时，非常激动，并且永远记下了。<br>
孩子，你说你16岁。我16岁时，是1971年。那时候，如果有人跟我说：“文化大革命是一场浩劫”，我一定会豁出去跟他争个头破血流，而且他就是说三天三夜道理也说服不了我。因为我从11岁起，接受的就是“文化大革命就是好”的教育，到我16岁时，这教育已经进行了五年。用三天三夜的道理来说服我，远远不够。同理，我也不可能解答你的疑惑。我就是说三年，写八本书，恐怕你也不会相信，因为你也有至少像我当年一样的五年。<br>
但是我要告诉你，孩子，你的疑惑迟早会得到解答。而那个答案，是你自己给自己的。十年，或是二十年后，有一天，你会想起来，哦，我那时好幼稚下作呀。因为那时的你，可能已是一个全新的你。当然，如果你走的是一帮极左人士指引的路，你或许就永远没有答案，并且终身挣扎在人生的深渊。<br>
孩子，我还要告诉你：我的16岁时代，比你差远了。我连“独立思考”这样的词都没有听说过。我从来不知道一个人需要独立思考，我的老师说什么就是什么，报纸说什么就是什么，收音机说什么就是什么。11岁开始“文革”，到21岁“文革”结束，这十年，我就是这样成长起来的。我从来没有过自己。因我从来就不是一个独立的人，只是一台机器上的螺丝钉。随着机器运转，机器停，我停，机器动，我动。这状态，大约也像今天的你（而不是你们，因为现今16岁孩子中很多人相当有独立思考能力）。<br>
幸运的是，我的父亲说：他一生最大的理想，就是希望自己的孩子全都能上大学。父亲说那番话的样子我还记得。所以我在当搬运工的时候，一心想实现父亲的遗愿，于是我考上了大学：中国最美丽的武汉大学。<br>
孩子，我经常为自己感到庆幸。虽然我的少年时代接受的尽是愚蠢的教育，但我却在青年时代得以进入大学。我在那里，如饥似渴地学习和阅读，与同学们一起讨论非常有意义的话题，并且开始了我的写作，终于有一天我知道了要独立思考。我还有幸地遇上了改革开放，更有幸参与了整个改革开放的全程。我看到结束“文革”浩劫的中国，从那样落后的状态，一步步强大。可以说，没有改革开放，几乎就没有今天的一切，包括我写这份公开的日记以及你给我写这封公开信的权利。这一点，我们都要庆幸。<br>
孩子，你知道吗？改革开放的前十年，几乎是我自己和自己斗争的十年。我要把过去挤压进我脑子里的垃圾和毒素一点点清理出去。我要装入新的东西，我要尝试用自己的眼光看世界，我要学会用自己的脑子思考问题。当然，学会这些，是建立在自己的成长经历、阅读、观察和努力的基础上。<br>
孩子，我一直以为这种自己与自己的斗争，自己给自己清除垃圾和毒素的事，只会在我这一代人中进行。意想不到的是：你和你的一些同伴，将来也会有这样的日子。那就是，自己与自己斗争，吧少年时代脑子里被灌入的垃圾和毒素，清理出去。这个过程，倒是不痛苦，每清理一次，就是一次解放。一次次的解放，会把一个僵化麻木带着锈迹的螺丝钉，变成一个真正的人。<br>
孩子，你听的懂吗？现在，我要把这一句诗送给你：“我也有过你们这样的青春，那时的我们就像今天的你们。”</p>
</blockquote>
<p><em>文章摘抄自原文，如有侵权请联系删除。</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《道连·葛雷的画像》 上海译文出版社]]></title>
        <id>https://ambeta.github.io/post/lesslessdao-lian-ge-lei-de-hua-xiang-greatergreater-shang-hai-yi-wen-chu-ban-she/</id>
        <link href="https://ambeta.github.io/post/lesslessdao-lian-ge-lei-de-hua-xiang-greatergreater-shang-hai-yi-wen-chu-ban-she/">
        </link>
        <updated>2020-07-07T02:51:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>你好像忘了我是个已经结婚的人，而结婚的唯一美妙之处，就是双方都绝对需要靠撒谎过日子。</p>
</blockquote>
<blockquote>
<p>女人是一种装饰用的性别。她们从来没有什么要讲的，可讲起来就是娓娓动听。女人代表着物质对精神的胜利，正像男人代表着精神对道德的胜利一样。</p>
</blockquote>
<blockquote>
<p>其实，每一种乐趣和快感可能都含有幸灾乐祸的成分，几乎没有例外。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[书影随感-序]]></title>
        <id>https://ambeta.github.io/post/shu-ying-sui-gan-xu/</id>
        <link href="https://ambeta.github.io/post/shu-ying-sui-gan-xu/">
        </link>
        <updated>2020-07-07T02:09:34.000Z</updated>
        <content type="html"><![CDATA[<p>自从开始了每天地铁通勤三小时的生活，我又把八岁高龄的泡面盖 kindle paperwhite 掏了出来，每天上下班路上看看书让痛苦的通勤时间多了一种享受（苦中作乐技能 MAX）。</p>
<p>消遣书籍中，我最爱看的还是偏向于纪实类的小说，就像我喜欢看剧情片一样，贴近现实让我比较能够构想出画面，而合乎情理的戏剧冲突又让我感受到现实生活中没有的魅力。我看书很慢，逐字逐句，在脑中勾画出一帧帧画面，进而组成一个个电影片段。这也是读书吸引我的一个地方，我感觉自己就是一个电影导演。</p>
<p>我很容易沉浸在小说或者电影的世界中，甚至故事结束之后我好些天都无法从那个世界出来，这样我也没办法紧接着去读下一本书或看下一部电影。这样在虚拟世界的弥留之际，不妨把自己的感想记录下来，也算是对那个世界做一个正式的告别，让我更快地可以进入下一个世界。</p>
<p>附图：八岁老 kindle<br>
<img src="https://ambeta.github.io/post-images/1594089890434.jpeg" alt="kindle paperwhite" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.4全国哀悼日——全(局域)网五十度灰]]></title>
        <id>https://ambeta.github.io/post/4-yue-4-ri-quan-guo-ai-dao-ri-quan-wang-wu-shi-du-hui/</id>
        <link href="https://ambeta.github.io/post/4-yue-4-ri-quan-guo-ai-dao-ri-quan-wang-wu-shi-du-hui/">
        </link>
        <updated>2020-04-04T11:55:03.000Z</updated>
        <content type="html"><![CDATA[<p>国务院紧急通知清明节当天全国哀悼，各个网站也赶紧实现了全站灰度呈现，一起来看看各大厂都是怎么干的。</p>
<h2 id="淘宝taobaocom">淘宝（taobao.com）</h2>
<figure data-type="image" tabindex="1"><img src="https://ambeta.github.io/post-images/1586001637288.png" alt="50度灰淘宝" loading="lazy"></figure>
<p>淘宝比较直接，直接在 <code>html</code> 根元素上添加了 <code>filter</code> 样式，同时也有对 IE6 的支持：</p>
<pre><code class="language-css">html {
    -webkit-filter: grayscale(100%);
    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);
}
</code></pre>
<h2 id="百度baiducom">百度（baidu.com）</h2>
<figure data-type="image" tabindex="2"><img src="https://ambeta.github.io/post-images/1586001911862.png" alt="50度灰百度" loading="lazy"></figure>
<p>百度做得更细致一些，直接精确到了对应的 DOM 元素，可以看到网站左上角的空气质量显示仍保留有颜色。<br>
技术实现上也是使用 <code>filter</code> 同时添加了对 IE6 的支持，但用了 postCSS 或类似的 CSS 预处理器，相比于淘宝的实现多了很多的 browser vendor prefix。</p>
<h2 id="腾讯qqcom">腾讯（qq.com）</h2>
<figure data-type="image" tabindex="3"><img src="https://ambeta.github.io/post-images/1586002406191.png" alt="50度灰腾讯" loading="lazy"></figure>
<p>腾讯网在 <code>body</code> 元素上添加了一个 css 样式类 <code>garyBody</code>（grayBody???），同样使用 <code>filter</code> 属性实现灰度变化，但是缺少了对 IE6 的支持。<br>
另一个值得注意的是，body 上的这个样式类是通过 js 动态插入的，所以在网站打开时会有一个从彩色切换到灰色的跳变，并且如果禁用了浏览器脚本执行的话，网站就无法切换到灰色模式了。</p>
<h2 id="京东jdcom">京东（jd.com）</h2>
<figure data-type="image" tabindex="4"><img src="https://ambeta.github.io/post-images/1586002807113.png" alt="50度灰京东" loading="lazy"></figure>
<p>京东也是直接在 <code>html</code> 根元素上添加了相应的样式，所使用的 css 属性与淘宝一致，不过使用的是类名选择器而不是标签选择器。<br>
另外，京东的整个网站是一个单页面应用，并且没有做首屏服务端渲染，所以禁用浏览器脚本的话网站基本无法使用，当然也没法切换到灰度模式：</p>
<figure data-type="image" tabindex="5"><img src="https://ambeta.github.io/post-images/1586003024944.png" alt="禁用脚本后的京东" loading="lazy"></figure>
<h2 id="总结吐槽">总结（吐槽）</h2>
<blockquote>
<p>腾讯的哥们最粗（单词拼错？缺乏IE6支持？）<br>
百度的哥们最细（精确到元素，可能网站结构比较简单吧:)）</p>
</blockquote>
<p>花了半个小时的时间写了一篇这么无聊的文章，了解了一个全站变灰的方式以及可能的坑，当然也不希望以后会用到这个技术吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 UPX 压缩可执行文件]]></title>
        <id>https://ambeta.github.io/post/shi-yong-upx-ya-suo-ke-zhi-xing-wen-jian/</id>
        <link href="https://ambeta.github.io/post/shi-yong-upx-ya-suo-ke-zhi-xing-wen-jian/">
        </link>
        <updated>2020-04-03T02:57:01.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://upx.github.io/">UPX</a> 可以有效地对可执行文件进行压缩，并且压缩后的文件可以直接由系统执行，支持多系统和平台。<br>
使用 UPX 来压缩可执行文件是一种减少发布包大小的有效方式。</p>
<h1 id="安装">安装</h1>
<ul>
<li>
<p>从 <a href="https://github.com/upx/upx/releases">github release page</a> 下载预编译的二进制文件</p>
</li>
<li>
<p>macOS 可以使用 brew 安装：</p>
<pre><code class="language-shell">brew install upx
</code></pre>
</li>
</ul>
<h1 id="使用">使用</h1>
<h2 id="压缩">压缩</h2>
<pre><code class="language-shell">upx [options] yourfile
</code></pre>
<p>upx 对文件的默认操作即为压缩，使用上述命令会使用默认参数压缩并替换文件 yourfile。<br>
upx 支持如下可选参数：</p>
<ul>
<li><code>-1[23456789]</code>：不同的压缩级别，数值越高压缩率越高，但耗时更长。对于小于 512 KiB 的文件默认使用 <code>-8</code>，其他的默认为 <code>-7</code>。
<ul>
<li><code>--best</code>：最高压缩级别</li>
<li><code>--brute</code>：尝试使用各种压缩方式来获取最高压缩比</li>
<li><code>--ultra-brute</code>：尝试使用更多的参数来获取更高的压缩比</li>
</ul>
</li>
<li><code>-o [file]</code>：将压缩文件保存为 [file]</li>
</ul>
<h2 id="解压">解压</h2>
<pre><code class="language-shell">upx -d [yourfile]
</code></pre>
<h1 id="优劣">优劣</h1>
<p>压缩的程序占用更少的硬盘空间，但会在打开时消耗更多的 CPU 资源，在运行时占用更多的内存（或 swap 空间、/tmp 存储等）。</p>
<h2 id="优点">优点</h2>
<ul>
<li>UPX 可以压缩各种类型的可执行文件</li>
<li>压缩后的文件可以直接由操作系统执行</li>
<li>压缩过程不会修改源文件，也就意味着解压后直接可以得到原始文件</li>
<li>不会产生额外的动态库调用</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>运行的程序不会共享数据段（<em>汇编</em>），所以多实例运行的程序不适合压缩</li>
<li>使用 <code>ldd</code> 和 <code>size</code> 命令无法获取到程序的有效信息</li>
</ul>
<h1 id="原理">原理</h1>
<h2 id="为什么压缩后的文件可由系统直接执行">为什么压缩后的文件可由系统直接执行？</h2>
<p>UPX 将程序压缩，并在头部加入解压的程序，具体的原理可以参看参考[2]。<br>
在 Linux 系统中可以使用 <code>strings</code> 命令查看可执行文件的内容，通过查看 UPX 压缩后的程序可以看到，UPX 在文件中写入了自己的特征码。</p>
<h1 id="参考">参考</h1>
<ul>
<li>1: <a href="https://github.com/upx/upx/blob/master/doc/upx.pod">UPX manual</a></li>
<li>2: <a href="https://dzone.com/articles/packers-how-they-work-featuring-upx">Packers, How They Work, Featuring UPX</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Padavan 上使用 trojan]]></title>
        <id>https://ambeta.github.io/post/zai-padavan-shang-shi-yong-trojan/</id>
        <link href="https://ambeta.github.io/post/zai-padavan-shang-shi-yong-trojan/">
        </link>
        <updated>2020-03-28T08:02:00.000Z</updated>
        <content type="html"><![CDATA[<p>由于目前所使用的 <a href="https://opt.cn2qq.com/padavan/">hiboy Padavan 固件</a> 还没有内置 trojan 代理的支持，因此只能使用自定义脚本的方式来部署。</p>
<p>本文主要分为三个部分：</p>
<ol>
<li>获取 trojan 程序</li>
<li>配置 trojan 启动脚本</li>
<li>配置透明代理</li>
</ol>
<h1 id="获取-trojan-程序">获取 trojan 程序</h1>
<p>由于目前 <a href="https://github.com/trojan-gfw/trojan">trojan</a> 没有提供 MIPS 平台的可执行文件，因此需要自行编译获取对应程序。</p>
<p>[hanwckf/Trojan-pdv-build] 已经提供了在 Linux 环境下进行交叉编译的相关脚本，我在此基础上稍作修改，利用 github actions 实现在线编译，并在编译时自动获取最新的 trojan 版本。具体操作如下：</p>
<ol>
<li>打开 <a href="https://github.com/AmBeta/Trojan-pdv-build">AmBeta/Trojan-pdv-build</a>，点击项目右上角的 Fork 按钮 fork 项目到自己的仓库</li>
<li>在自己 fork 的项目里，点击右上角的 Star 按钮触发构建操作</li>
<li>在项目的 Actions 面板中可以看到当前的构建进度，构建完成后就可以下载生成的文件了</li>
</ol>
<h1 id="配置-trojan-启动脚本">配置 trojan 启动脚本</h1>
<h2 id="1-新建-trojan-客户端配置文件">1. 新建 trojan 客户端配置文件</h2>
<p>新建一个文本文档，录入以下内容，保存文件名为 <code>trojan_config.sh</code>。<br>
<strong>注意</strong>修改文件内容中的 <code>&lt;Server Host&gt;</code>，<code>&lt;Server Port&gt;</code>，<code>&lt;Password&gt;</code> 为你的服务器对应的域名、端口号和密码。</p>
<pre><code class="language-json">{
    &quot;run_type&quot;: &quot;client&quot;,
    &quot;local_addr&quot;: &quot;&lt;RouterIP&gt;&quot;,
    &quot;local_port&quot;: 1080,
    &quot;remote_addr&quot;: &quot;&lt;Server Host&gt;&quot;,
    &quot;remote_port&quot;: &lt;Server Port&gt;,
    &quot;password&quot;: [
        &quot;&lt;Password&gt;&quot;
    ],
    &quot;log_level&quot;: 2,
    &quot;ssl&quot;: {
        &quot;verify&quot;: true,
        &quot;verify_hostname&quot;: true,
        &quot;cert&quot;: &quot;&quot;,
        &quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:AES128-SHA:AES256-SHA:DES-CBC3-SHA&quot;,
        &quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;,
        &quot;sni&quot;: &quot;&quot;,
        &quot;alpn&quot;: [
            &quot;h2&quot;,
            &quot;http/1.1&quot;
        ],
        &quot;reuse_session&quot;: true,
        &quot;session_ticket&quot;: false,
        &quot;curves&quot;: &quot;&quot;
    },
    &quot;tcp&quot;: {
        &quot;no_delay&quot;: true,
        &quot;keep_alive&quot;: true,
        &quot;reuse_port&quot;: false,
        &quot;fast_open&quot;: false,
        &quot;fast_open_qlen&quot;: 20
    }
}
</code></pre>
<h2 id="2-新建-trojan-客户端启动脚本">2. 新建 trojan 客户端启动脚本</h2>
<p>新建一个文本文档，录入以下内容，保存文件名为 <code>trojan_start.sh</code>。</p>
<pre><code class="language-shell">#!/bin/sh
# 启动前运行的脚本
export PATH='/etc/storage/bin:/tmp/script:/etc/storage/script:/opt/usr/sbin:/opt/usr/bin:/opt/sbin:/opt/bin:/usr/local/sbin:/usr/sbin:/usr/bin:/sbin:/bin'
export LD_LIBRARY_PATH=/lib:/opt/lib
export SSL_CERT_FILE=/etc/storage/cacert.pem

# kill existing trojan process
killall trojan

# startup
logger -t &quot;【trojan】&quot; &quot;启动 trojan 客户端&quot;
trojan -c /etc/storage/trojan_config.sh 2&gt;&amp;1 | logger -t &quot;【trojan】&quot; &amp;
</code></pre>
<p>在命令行中输入以下命令为文件添加可执行权限：</p>
<pre><code class="language-shell">chmod +x trojan_start.sh
</code></pre>
<h2 id="3-下载证书">3. 下载证书</h2>
<p>trojan 使用 tls 与服务器建立连接，因此需要用到相关的证书，否则可能会遇到无法验证证书从而无法建立连接的问题。（<a href="https://github.com/shadowsocks/v2ray-plugin/issues/53">mipsle not work properly at padavan Router #53</a>）<br>
使用如下命令下载证书：</p>
<pre><code class="language-shell">curl -O https://curl.haxx.se/ca/cacert.pem
</code></pre>
<h2 id="4-上传文件到路由器">4. 上传文件到路由器</h2>
<p>在命令行中使用 scp 命令将以上文件拷贝到路由器（<strong>注意</strong>将 root 替换为路由器管理页面登录的用户名）。</p>
<pre><code class="language-shell">scp trojan root@192.168.123.1:/etc/storage/bin
scp trojan_config.sh trojan_start.sh cacert.pem root@192.168.123.1:/etc/storage
</code></pre>
<p>由于 Padavan 特殊的安全机制，路由器重启后未执行保存命令的文件会丢失，因此需要执行一次保存操作。打开路由器的 webUI 管理页面，依次点击 <code>高级设置-&gt;系统管理-&gt;恢复/导出/上传设置-&gt;保存 /etc/storage/ 内容到闪存-&gt;提交</code>，等待片刻即可。</p>
<h2 id="5-webui-配置启动自定义脚本">5. webUI 配置启动自定义脚本</h2>
<p>配置路由器启动时自动启动 trojan 客户端。依次点击 <code>高级设置-&gt;自定义设置-&gt;脚本-&gt;在路由器启动后执行</code>，在输入框中追加如下脚本：</p>
<pre><code class="language-shell">/etc/storage/trojan_start.sh &amp;
</code></pre>
<h1 id="配置透明代理">配置透明代理</h1>
<p>由于路由器性能有限，这里使用 ss_tproxy + transocks + trojan 的组合作为路由器透明代理的方案。<br>
在 <code>扩展功能-&gt;广告屏蔽功能-&gt;transocks</code> 页面配置 transocks 透明代理服务：</p>
<figure data-type="image" tabindex="1"><img src="https://ambeta.github.io/post-images/1585386892335.png" alt="transocks 配置" loading="lazy"></figure>
<p>Padavan 固件的内置脚本会自动启用 ss_tproxy，等待脚本执行完成后路由器透明代理就设置完成了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重定向 bash 脚本输出到系统日志]]></title>
        <id>https://ambeta.github.io/post/chong-ding-xiang-bash-jiao-ben-shu-chu-dao-xi-tong-ri-zhi/</id>
        <link href="https://ambeta.github.io/post/chong-ding-xiang-bash-jiao-ben-shu-chu-dao-xi-tong-ri-zhi/">
        </link>
        <updated>2020-03-18T06:00:13.000Z</updated>
        <content type="html"><![CDATA[<p><em>【TL;DR】最近在家里的小米 R3G（刷了 Padavan 系统）部署 trojan 客户端，由于 hiboy 的固件没有预装 trojan，于是只能手写开机脚本。脚本写好了，但是从路由器的 webUI 上看不到启动日志，于是有了这篇文章。</em></p>
<h1 id="how">HOW</h1>
<h2 id="exec-1-logger-s-t-basename-0-21"><code>exec 1&gt; &gt;(logger -s -t $(basename $0)) 2&gt;&amp;1</code></h2>
<p>在脚本的开头插入上述的命令可以将脚本中所有的输出重定向到系统日志中。</p>
<h2 id="command-21-logger-s-t-basename-0"><code>[command] 2&gt;&amp;1 | logger -s -t $(basename $0)</code></h2>
<p>使用管道运算符将标准输出作为系统日志的标准输入。<br>
同时，shell 提供了与 <code>2&gt;&amp;1</code> 等价的快捷方式 <code>|&amp;</code> 可以替换使用。</p>
<h1 id="reference">Reference</h1>
<p><a href="https://www.urbanautomaton.com/blog/2014/09/09/redirecting-bash-script-output-to-syslog/">Redirecting bash script output to syslog</a><br>
<a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">bash manual: Redirections</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用 AST 对项目代码进行迁移]]></title>
        <id>https://ambeta.github.io/post/li-yong-ast-dui-xiang-mu-dai-ma-jin-xing-qian-yi/</id>
        <link href="https://ambeta.github.io/post/li-yong-ast-dui-xiang-mu-dai-ma-jin-xing-qian-yi/">
        </link>
        <updated>2017-08-13T08:15:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>The more code you have, the harder it becomes to make big, sweeping changes quickly and confidently. Even if you trust yourself not to make too many mistakes, and no matter how proficient you are with your text editor, changing tens of thousands of lines of code takes precious, non-refundable time.</p>
</blockquote>
<p>项目写了一段时间之后，如果再进行项目的调整，那往往是比较繁琐的事情，不是在编辑器中使用全文检索和替换能够解决的了。</p>
<p>在看 React 官方文档时，看到他们使用 <a href="https://github.com/reactjs/react-codemod">react-codemod</a> 来解决 React 版本更新造成的 API 使用的问题，于是看了一下这种方案是如何实现的。</p>
<h4 id="react-codemod"><a href="https://github.com/reactjs/react-codemod">react-codemod</a></h4>
<p>首先 react-codemod 项目提供的仅仅是一些转化的脚本，而这些转化脚本主要是提供给 <a href="https://github.com/facebook/jscodeshift">jscodeshift</a> 这个工具使用的。</p>
<h4 id="jscodeshift"><a href="https://github.com/facebook/jscodeshift">jscodeshift</a></h4>
<p>jscodeshift 的核心则是由 <a href="https://github.com/benjamn/recast">recast</a> 提供，jscodeshift 对 recast 进行了自己的封装，添加了 <code>Collection</code> 类使得对 AST 操作的 API 更加易于使用，也提高了操作的可拓展性，同时该工具也提供了对文件以及文件夹的多线程操作，并可以给出最后转化的结果（成功或失败的文件数）。</p>
<h4 id="recast"><a href="https://github.com/benjamn/recast">recast</a></h4>
<p>recast 这个工具则是核心，其提供了对源码进行 AST 分析以及修改的能力，同时可以最大程度地保留原代码的格式，对于 AST 中没有修改的部分，他会原封不动地进行输出，其也支持对 AST 进行格式化的代码输出，提供了部分可定制的代码格式化选项。</p>
<h4 id="api">API</h4>
<p>代码的范例可以参看 react-codemod 项目，由于没有找到详细的 API 文档，这里就列出一部分个人认为比较重要的 API。</p>
<ul>
<li><code>jscodeshift(code: string)</code><br>
根据源码 <code>code</code> 生成 AST，返回一个 <code>Collection</code> 对象。</li>
<li><code>Collection.find(nodeType: ASTTypes, predictor: any)</code><br>
从 <code>Collection</code> 中过滤出所有 <code>nodeType</code> 节点类型的节点，返回一个 <code>Array&lt;NodePath&gt;</code> 数组可用于迭代。</li>
<li><code>Collection.replace(nodes: NodePath | NodePath[])</code><br>
用 <code>nodes</code> 节点替换 <code>Collection</code> 中的<strong>每个</strong> <code>NodePath</code>。</li>
<li><code>Collection.insertBefore/Collection.insertAfter(nodes: NodePath | NodePath[])</code><br>
在 <code>Collection</code> 中的<strong>每个</strong> <code>NodePath</code> 前/后插入 <code>nodes</code> 节点。</li>
<li><code>Collection.paths()</code><br>
获取 <code>Collection</code> 中的所有 <code>NodePath</code>，返回一个 <code>Array&lt;NodePath&gt;</code> 数组。</li>
</ul>
<p>关于 AST 操作的更多 API 可以参看 <a href="https://github.com/benjamn/recast">recast</a> 的文档以及 <a href="https://github.com/benjamn/ast-types">ast-types</a> 的文档以及相关的源码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Stapes框架下实现一个模态框的实践方法]]></title>
        <id>https://ambeta.github.io/post/zai-stapes-kuang-jia-xia-shi-xian-yi-ge-mo-tai-kuang-de-shi-jian-fang-fa/</id>
        <link href="https://ambeta.github.io/post/zai-stapes-kuang-jia-xia-shi-xian-yi-ge-mo-tai-kuang-de-shi-jian-fang-fa/">
        </link>
        <updated>2016-07-04T10:38:00.000Z</updated>
        <content type="html"><![CDATA[<p>使用Stapes创建一个基于MVC的数据列表页面时，页面的MVC逻辑比较清晰——所有的数据条目是一个 <code>Model</code>，列表的展示是对应的 <code>View</code>，<code>Controller</code> 则将视图的事件转化为对数据模型的操作。</p>
<p>对于列表中的每一条数据，由于其是一个独立的数据，因此可以建立一个数据模型用来存储，点击之后弹出模态框，对于这个模态框的设计，如何能保证清晰的逻辑呢？</p>
<p>假设列表的 MVC 实现代码如下：</p>
<pre><code>/* List Model */
var DataModel = Stapes.subclass({
    constructor : function (cfg) {
        // initialize...
    }
});
DataModel.proto({
    updateData : function (params) {
        // ajax request
    }
});

/* List View */
var DataView = Stapes.subclass({
    constructor : function (cfg) {
        this.model = cfg.model || null;
        this.$body = cfg.body || $('body');
        
        this.render();
        this.bindEvents();
    }
});
DataView.proto({
    render : function () {},

    bindEvents : function () {
        this.$body.on('click', 'button', function () {
            var modal = new SomeModal({});
        });
    }
});

/* List Controller */
var DataController = Stapes.subclass({
    constructor : function (cfg) {
        this.model = cfg.model || null;
        this.view = cfg.view || null;
        if (!this.model || !this.view) {
            throw ('DataController init failed!');
        }

        bindEvents();
    }
});
DataController.proto({
    // bind model events
    this.model.on({
        update : function (params) {
            this.model.updateData(params);
        }
    }, this);
    
    // bind view events
    this.view.on({
        update : function (params) {
            this.model.emit('update', params);
        }
    }, this);
});

</code></pre>
<h2 id="仅供查看数据的模态框">仅供查看数据的模态框</h2>
<p>仅供查看数据的模态框是比较容易处理的，这时模态框就是一个单纯的 <code>View</code>，其绑定的数据模型就是列表中的那一条数据。</p>
<pre><code>var InfoModal = Stapes.subclass({
    constructor : function (cfg) {
        this.model = cfg.model || null;
    }
});
</code></pre>
<h2 id="新增或修改数据的模态框">新增或修改数据的模态框</h2>
<p>对于新增或者修改的模态框，情况就比较复杂了，因为用户可以在模态框中对用户的数据进行操作。</p>
<p>根据 MVC 的思想，我们要尽量避免在 <code>View</code> 中对数据模型进行直接的操作，<code>View</code> 应该通过发出事件的方式让 <code>Controller</code> 去捕捉并操作 <code>Model</code>，但是用一个完整的 MVC 去实现一个简单的模态框未免太过周折，并且两个 <code>Controller</code> 之间的通讯问题会把逻辑绕得更加复杂。</p>
<p>如何写出一个逻辑清晰的模态框组件，总结了有下面几个思路：</p>
<ul>
<li>直接操作数据模型</li>
<li>提供回调</li>
<li>绑定父视图</li>
</ul>
<h3 id="直接操作数据模型">直接操作数据模型</h3>
<p>说是直接操作 <code>Model</code>，但也是通过事件机制与 <code>Model</code> 进行通讯的，但是由于模态框没有自己的 <code>Controller</code>，只能够直接发出 <code>Model</code> 上的事件，因此这种事件机制与直接操作 <code>Model</code> 并无太大的区别。</p>
<p>另一种情况是，我们需要在模态框中直接操作另一组数据。</p>
<h3 id="提供回调">提供回调</h3>
<p>我们可以为调用该模态框的视图提供一个回调，将用户在模态框中对数据的修改以参数的方式传回。</p>
<p>用这种方式实现的模态框逻辑很简单，只需要将 <code>Model</code> 中的数据表现出来，然后再将用户的输入传回就好了，不需要关心对 <code>Model</code> 的具体操作与结果。</p>
<pre><code>var EditModal = Stapes.subclass({
    constructor : function (cfg) {
        this.model = cfg.model || null;
        this.cbFn = cfg.cbFn || function () {};
        
        this.$body = null;  // get initialized in `render()`

        this.render();
        this.bindEvents();
    }
});
EditModal.proto({
    bindEvents : function () {
        var self = this;
        self.$body.on('click', '.btn-ok', function () {
            var params = self.getPostParams();
            self.cbFn.call({}, params);
        });
    }
});
</code></pre>
<p>这时，在列表视图中，可以这样新建一个模态框：</p>
<pre><code>var self = this;    // `this` points to the list view
var modal = new EditModal({
    model : dataModel,
    cbFn : function (params) {
        self.emit('update', params);
    }
});
</code></pre>
<h3 id="绑定父视图">绑定父视图</h3>
<p>有时在模态框中的操作过于复杂，需要提供多个回调，这样就可以将父视图绑定到这个模态框上，这个模态框就相当于其父元素的一个组成部分，其可以触发父元素上的事件。</p>
<pre><code>var EditModal = Stapes.subclass({
    constructor : function (cfg) {
        this.model = cfg.model || null;
        this.parentView = cfg.parentView || null;
    
        this.$body = null;  // get initialize in `render()`

        this.render();
        this.bindEvents();
    }
});
EditModal.proto({
    bindEvents : function () {
        var self = this;
        self.$body.on('click', '.btn-ok', function () {
            var params = self.getPostParams();
            self.parentView.emit('update', params);
        });
    }
});
</code></pre>
<h4 id="更多">更多</h4>
<ul>
<li>使用 ember.js 创建一个模态框的讨论：<br>
http://discuss.emberjs.com/t/modal-views-can-we-agree-on-a-best-practice/707/5</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用jekyll建站]]></title>
        <id>https://ambeta.github.io/post/ru-he-shi-yong-jekyll-jian-zhan/</id>
        <link href="https://ambeta.github.io/post/ru-he-shi-yong-jekyll-jian-zhan/">
        </link>
        <updated>2016-03-27T15:35:00.000Z</updated>
        <content type="html"><![CDATA[<p>终于把自己的个人博客折腾好了，可以开开心心地发博文啦！</p>
<p>个人博客这种东西，主要是为了记录一下自己成长的过程，其次也可以作为与其他人交流共享一些经验的平台，而对于我这种健忘的人则是个必不可少的东西，不然过些时日，连jekyll怎么拼的都会忘掉了Orz。。</p>
<p>之前也尝试在CSDN上维护自己的博客，但是感觉发文危险系数很高，审核慢就不说了，万一审核不过，码了半天的字都白费了，很是难受，听说Github可以免费挂个人主页，果断尝试一波。</p>
<p>建站选用的是jekyll这个工具，可以与Github配合使用，其他的还有Hexo等建站工具。</p>
<h2 id="jekyll简介">jekyll简介</h2>
<p>jekyll是一个可以将纯文本转化为静态网站的工具，因可以与github pages完美契合而受到很多程序猿的青睐。</p>
<p><a href="http://www.bootcss.com/">Bootstrap中文网</a>对jekyll的描述如下：</p>
<blockquote>
<p>简单：无需数据库、评论功能，不需要不断地更新版本——只用关心你的博客内容<br>
静态：只用Markdown（或Textile）、Liquid、HTML&amp;CSS就可以构建可部署的静态网站<br>
博客形态：自定义地址、分类、页面、博客内容以及自定义的布局设计都是系统中一等公民</p>
</blockquote>
<hr>
<h2 id="jekyll手动建站">jekyll手动建站</h2>
<p>jekyll用的人很多，网上也有很多现成的模板供大家选用。起初我也想选个模板直接进入写博客的正题，但是找了很久都找不到心仪的模板，有的功能非常赞，但是页面风格不是我的style，有的风格很赞，但是功能又过于繁复。索性自己摸索做一个属于自己的，顺便学习一下这个工具的使用，毕竟用jekyll＋Github不发挥点geek精神有点不合适吧。</p>
<p>Anyway，如果只想火速建个站，可以直接跳转到<a href="#jekyll-template">应用<strong>jekyll模板</strong></a>。</p>
<h3 id="环境搭建">环境搭建</h3>
<p>jekyll的环境搭建非常简单，使用如下命令即可建立一个新的站点：</p>
<pre><code>~ $ gem install jekyll
~ $ jekyll new myblog
~ $ cd myblog
~/myblog $ jekyll serve
</code></pre>
<p>完成上述命令之后，用浏览器访问<code>http://localhost:4000</code>即可打开这个新的站点（当然现在什么都没有）。</p>
<p><em>PS：</em> 环境搭建中遇到的问题可以参考<a href="http://jekyll.bootcss.com/docs/quickstart/">jekyll快速指南</a>尝试获取解决方案。</p>
<h3 id="目录结构">目录结构</h3>
<p>一般情况下jekyll的目录结构如下，其中<code>[*]</code>是必选项（如果你想只写一个index.html的话就不需要用jekyll啦- -），而为了获得较好的站点结构以便后续的维护，下面的这个目录结构是最基本的。</p>
<pre><code>/myblog
    |-- _includes
          |-- head.html
          |-- nav.html
          |-- footer.html
    |-- _layouts [*]
          |-- default.html
          |-- page.html
          |-- post.html
    |-- _posts [*]
          |-- 2016-03-23-hello-world.md
    |-- imgs
    |-- css
          |-- main.css
    |-- fonts
    |-- js
    |-- _config.yml [*]
    |-- index.html [*]
</code></pre>
<ul>
<li><code>_layouts</code>中存放的是页面的布局文件。</li>
<li><code>_includes</code>中存放的是一些文档的组成部分，一般可以被<code>_layouts</code>中的页面布局文件所引用，以减少代码的重复，通常可以用来布局一些html文件头、导航条以及页面脚注等。</li>
<li><code>_posts</code>中存放的是发布的博文。</li>
<li><code>imgs</code>中存放的是网站用到的所有图片资源。</li>
<li><code>css</code>, <code>fonts</code>, <code>js</code>中存放的分别是页面引用的所有样式表、字体文件以及脚本。</li>
<li><code>_config.yml</code>文件是整个站点的配置文件。</li>
<li><code>index.html</code>文件即为站点的主页。</li>
</ul>
<p>大部分情况下，除了站点主页外，一个站点中还会含有<code>404.html</code>, <code>about.html</code>等页面，用于更加完善的个人主页以及更佳的访客体验，当然这些都不是必须的，只要你的博文写的够精彩，这些都不是重点～</p>
<h3 id="常用语法">常用语法</h3>
<p>在介绍不同文件的配置之前，首先需要了解一下jekyll中常用的一些语法规则，这些在编写页面布局文件的时候极为有用，后续博文信息的自动化生成方面就全靠它了。</p>
<ul>
<li>jekyll中的<strong>全局变量</strong>主要有<code>site</code>, <code>page</code>, <code>paginator</code>, <code>content</code>，而前三者又更像是一个对象，其中包含着其他的变量，使用<code>.</code>运算符即可访问，例如使用<code>site.title</code>可以访问站点名字变量。</li>
<li>jekyll中<strong>语句</strong>使用<code>{ %</code>和<code>% }</code>进行包裹，且每一个语句块都需要显示地闭合，例如<code>{ % if % } blablabla { % endif % }</code>即为一个条件语句块。</li>
<li>jekyll中使用双重大括号包裹的变量表示<strong>取值</strong>运算，例如<code>{ { page.title } }</code>语句可以取得<code>page.title</code>的值。</li>
</ul>
<h3 id="文件配置">文件配置</h3>
<h5 id="_configyml-站点配置文件">_config.yml － 站点配置文件</h5>
<p>该文件中保存的主要是整个站点的配置，其中的每项配置都作为全局变量<code>site</code>的成员变量可以在任意站点文件中访问到。</p>
<p>一个常见的站点配置文件可能长得像下面这样：</p>
<pre><code># Site settings
title: AmBeta Blog
SEOTitle: 三土的博客 | AmBeta Blog
header-img: imgs/header-bg.png
header-thumb: imgs/my-thumb.png
email: cyandrewchen@gmail.com
description: &quot;&quot;
keyword: &quot;&quot;
url: &quot;http://ambeta.github.io&quot;  # your host, for absolute URL
baseurl: &quot;&quot;  

# Build settings
gems: [jekyll-paginate]
paginate: 5
exclude: [&quot;less&quot;,&quot;node_modules&quot;,&quot;Gruntfile.js&quot;,&quot;package.json&quot;,&quot;README.md&quot;]

# Markdown settings
markdown: kramdown
kramdown:
  input: GFM
</code></pre>
<h5 id="layouts-页面布局">layouts － 页面布局</h5>
<p>该文件夹下存放的是所有的页面布局文件，页面布局文件是一系列的<code>.html</code>文件，如下是一个典型的页面布局文件：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;

{ % include head.html % }

&lt;body&gt;
    { % include navbar.html % }

    { { content } }

    { % include footer.html % }

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>使用<code>{ % include head.html % }</code>语句可以引入<code>_includes</code>文件夹中<code>head.html</code>的所有内容。</li>
<li>使用<code>{ { content } }</code>语句会将使用该模版的文件的内容填充到这里。</li>
</ul>
<h5 id="indexhtml-站点主页">index.html － 站点主页</h5>
<p>jekyll会将该文件识别为站点的主页，同时Github也将识别该文件作为当访问你的Github pages时会显示的页面。<br>
<strong>注意</strong>该文件的名称一定要为<code>index.html</code>。<br>
在文件头部使用如下配置语句可以指定页面所用的模板：</p>
<pre><code>---
layout: default
---
</code></pre>
<h5 id="posts-博文">posts － 博文</h5>
<p>该文件夹下存放的是所有的博文。<br>
jekyll支持多种markdown引擎（有需求的话可以在<code>_config.yml</code>文件中自定义引擎选择）。<br>
jekyll要求每篇博文的名字都遵循如下的格式：</p>
<pre><code>Year-Month-Date-PostTitle
</code></pre>
<p>例如<code>2016-03-22-hello-world.md</code>, <code>2020-02-22-byebye-world.textile</code>都是合法的博文命名。<br>
博文头部定义的变量可以作为<code>page</code>变量的成员变量被访问到，常见的博文头部如下：</p>
<pre><code>title: Hello World
date: 2016-03-22
layout: post
</code></pre>
<h3 id="更多功能">更多功能</h3>
<h5 id="paginator-分页">paginator － 分页</h5>
<p>jekyll支持自动分页，在<code>_config.yml</code>文件中加上如下配置可开启分页功能，可以控制每页的最大显示条目数量。<br>
例如，在<code>index.html</code>文件中使用如下语句可以分页显示所有博文的摘要信息：</p>
<pre><code>&lt;!-- Post Content Preview --&gt;
{ % for post in paginator.posts % }
&lt;div class=&quot;post-preview&quot;&gt;
	&lt;a href=&quot;{ { post.url | prepend: site.baseurl } }&quot;&gt;
		&lt;h2 class=&quot;post-title&quot;&gt;
			{ { post.title } }
		&lt;/h2&gt;
		&lt;div class=&quot;post-content-preview&quot;&gt;
			{ { post.content | strip_html | truncate:100 } }
		&lt;/div&gt;
	&lt;/a&gt;
	&lt;p class=&quot;post-meta&quot;&gt;
		Posted on { { post.date | date: &quot;%B %-d, %Y&quot; } }
	&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
{ % endfor % }
</code></pre>
<p>更多关于分页的信息可参考<a href="http://jekyll.bootcss.com/docs/pagination/">jekyll分页功能</a>。</p>
<hr>
<h2 id="a-namejekyll-templatea应用jekyll模板"><a name="jekyll-template"></a>应用jekyll模板</h2>
<p>当你物色到一个很喜欢的theme时，你就可以fork一下（如果人家愿意的话），然后稍作修改就可以开始你的博客之旅了。</p>
<p>主要需要注意修改的有以下几个方面：</p>
<ol>
<li><code>_config.yml</code>文件中的站点名称、地址及其他个人信息与站点配置。</li>
<li>修改主要布局文件如<code>head.html</code>, <code>footer.html</code>, <code>index.html</code>中包含的个人信息。</li>
</ol>
<p><em><strong>PS：</strong></em> 如果theme的作者有在Github上维护关于该theme的说明文档的话，那就按照作者的指引进行相应的配置就好啦～</p>
<p>上述的修改完成后就可以在<code>posts</code>文件夹中添加自己的博文了。</p>
<hr>
<h2 id="本地调试页面">本地调试页面</h2>
<p>当火速写完一篇 <em>Hello World</em> 博文之后迫不及待地就想看看 <em>World</em> 到底有没有听到你的呼唤。</p>
<p>使用命令行进入站点的根目录，输入以下命令：</p>
<pre><code>jekyll serve
</code></pre>
<p>jekyll便随即开始编译生成站点文件（存放在<code>_site</code>目录中），如果一切正常的话，jekyll会告诉你本地服务器部署的IP及端口号，打开浏览器进行访问即可。</p>
<p>在命令行中添加<code>--watch</code>选项可以让jekyll随时监听文件的变化并生成更新后的文件。</p>
<hr>
<h2 id="发布到github">发布到Github</h2>
<p>使用Git工具将站点同步到Github仓库上，一切就大功告成啦～！</p>
<pre><code>~ $ git branch    // * master
~ $ git commit -a -m &quot;commit comment&quot;
~ $ git push origin master
</code></pre>
<p>如果问题卡在使用Github Pages建立个人主页方面，可以参考<a href="https://segmentfault.com/a/1190000002765287">用Github来部署静态网页</a>，这篇文章写得很详细，当然，<a href="https://help.github.com/categories/github-pages-basics/">Github官网</a>也有相关的用户指引。</p>
]]></content>
    </entry>
</feed>